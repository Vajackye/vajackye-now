* 一维前缀和：
* 位运算相同性质：s[i,j] = s[1,i-1]^s[1,j] = s[1,i-1]^(s[1,i-1]^s[i,j])= 0^s[i,j]=s[i,j];


* 二维前缀和：计算公式（可自己推导）：https://blog.csdn.net/weixin_45629285/article/details/111146240
* 预处理公式（即求该范围的面积大小，即和大小）：s[i][j] = s[i - 1][j] + s[i][j - 1 ] + a[i] [j] - s[i - 1][j - 1]
* 公式：s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]（以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为）

* 一维差分：https://www.bilibili.com/video/BV1vY411B7jg/?t=1863.1&vd_source=9b8c617d6963309a6ee72210dfcda8fa

* 在后一个元素减去前一个元素后，前一个差分加z值，然后后一个元素还原时，要加差分和上一个元素，结果发现，该元素也添加了z值，（因为前一个元素还原时加z了），所以在该范围内最后一个元素的下一个元素开始要减去z
* 对于差分，修改的其实是sub[l] 和 sub[r+1]两个位置的差分，sub[l]+m,则sub[r+1]-m（还原，和数值不变）。所以当sub差分全为0时，全元素相等。
* 还有假设法。假设差分全0，在依次修改差分。
* https://matiji.net/exam/dohomework/2791/4 （码蹄集相对马高）
* 

* 二维差分：https://www.bilibili.com/video/BV1vY411B7jg/?t=1797.2&vd_source=9b8c617d6963309a6ee72210dfcda8fa

* 位运算（枚举2进制所有情况（即01选取））：
```c++
 for(int i = 0; i<(i<<n)/*最大二进制数2^n，n为长度序列*/; i++) {
    for(int j = 0; j < n/*每次循环的最大次数（一般都是长度序列，看题目而定）*/; j++) {
      if((i>>j)&1) {}//这种情况便是在枚举每一种情况（顺序打乱，但是最后每个情况如：000,001,010,011,100,101,110,111...都列出来了）
      }
    }
```
* 具体例子：码蹄集：剪刀石头布，参考题解：https://www.bilibili.com/video/BV1RR4y1Q7jL/?t=2529.3&vd_source=9b8c617d6963309a6ee72210dfcda8fa

---------
* 位运算取反操作：即： ~5 = ~（101） = 010
