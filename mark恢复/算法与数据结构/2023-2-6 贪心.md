**（本节只有思路，没有代码，思路中只有关键思路，有些步骤会省略，例如排序等，除了一些可能会用到的未学的知识代码外）**
* 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。
* **没有技巧，全是熟练度，灵感，严格数学证明还得是学数学**
* **刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心，至于严格的数学证明，就不在讨论范围内**
---
> 题一：455.分发饼干：https://leetcode.cn/problems/assign-cookies/
>>* 思路一：大饼干喂饱大胃口，胃口外循环，饼干if判断内自减（双指针思想遍历）
>>* 思路二：小饼干喂饱小胃口，饼干外循环，胃口if判断内自增（双指针思想遍历）

> 题二：376.摆动序列：https://leetcode.cn/problems/wiggle-subsequence/
>>* 思路一：考虑每一个局部峰值，一个峰值代表一个长度，删除单调性多节点的坡线得到更多峰值，从而拉长长度，分①上下坡有平坡；②数组首尾两端不特判（比如2为长度的数组，两个元素，可归并为第一种情况的情况，所以，长度起始可以设为1而不是0）；③单调坡度有平坡，可能会多统计一个峰值
>>* 思路二：（动态规划dp）

> 题三：最大子序和：https://leetcode.cn/problems/maximum-subarray/
>>* 思路一：负数会拉低和，所以连续和变小或者小于0时（正数），重置连续和起始位置（sum=0，重新初始化），再继续循环，每次循环时要判断当前连续和是否大于之前，大于就更新保存。（对于负数，一样的，小于零无所谓，一般都是重置），为包含全负数情况令记录变量值初始化为：INT32_MIN;//int 最小。
>>* 思路二：（动态规划dp）

>题四：买卖股票的最佳时机II:https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
>>* sl:最终利润是可以分解的.局部最优：收集每天的正利润，全局最优：求得最大利润
>>* dp：

>题五：跳跃游戏I：https://leetcode.cn/problems/jump-game/
>>* sl:每次取每个点的最大覆盖范围，检查在覆盖范围内是否能走到终点。在范围内不必管如何走，只要看能否走到终点。局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点

>题六：跳跃游戏II：https://leetcode.cn/problems/jump-game-ii/
>>* sl:每次取每个点的最大范围，检查当前最大范围与下一步位置最大范围覆盖区域能否到达终点，不能则步数再加。

>题七：K次取反后最大化的数组和：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/
>>* sl:贪心1：反转绝对值大的数，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。贪心2：反转值小的自然数。局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大

>题八：加油站：https://leetcode.cn/problems/gas-station/
>>* 暴力模拟：https://www.programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%96%B9%E6%B3%95%E4%B8%80
>>* sl：总油量大于等于总耗油量则说明有解，则计算每点的耗油量，连续耗油量大于连续得油量则更新起始下标，最后循环完得出总油量更大，则返回循环最后更新的下标，否则返回false。只要总油量更大，必有一个解，因为连续负的情况下总有一个很大的得油点可以解决其他点的问题。
>>* 全局模拟：代码：
```c++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int min = INT_MAX; // 从起点出发，油箱里的油量最小值
        for (int i = 0; i < gas.size(); i++) {
            int rest = gas[i] - cost[i];
            curSum += rest;
            if (curSum < min) {
                min = curSum;
            }
        }
        if (curSum < 0) return -1;  // 情况1,gas的总和小于cost总和
        if (min >= 0) return 0;     // 情况2,rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点
                                    // 情况3,如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点
        for (int i = gas.size() - 1; i >= 0; i--) {
            int rest = gas[i] - cost[i];
            min += rest;//从最后往前，一个个加，加到能使这些负数抵消的位置，则此为起点，足以抵消之后的连续负数.
            if (min >= 0) {
                return i;
            }
        }
        return -1;
```

>题九（难）：分发糖果：https://leetcode.cn/problems/candy/
>>* 向后遍历（右大于左），向前遍历（左大于右），两次贪心，取两次遍历的获得糖果中最值，确保高分孩子的糖果比两边都高，且老师花销糖果最少，至于为什么两次遍历方向不一样，原因是，要利用前一次遍历的结果，进行比较，取糖果最大值，全局最优：分高比左右俩都多，图解如下：![1675756889581](https://user-images.githubusercontent.com/121871885/217186280-527a1f48-60a4-4838-b018-0d45390c3804.jpg)

>题十：柠檬水找零：https://leetcode.cn/problems/lemonade-change/
>>* 三种情况：5元拿下，10元返5，20优先反5+10，无10则5+5+5.局部最优：优先消耗10。全局最优：完成账单找零。f分类讨论即可，灵活运用if，else if先后顺序判断。

>题十一：根据身高重建队列：https://leetcode.cn/problems/queue-reconstruction-by-height/
>>* 跟题九一样，有两个维度，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。先身高排序，同身高k小往后，先k排序没卵用。局部最优：然后按身高高的k小的先插入，身高低的在插入。因为身高低的插入时不会影响身高高的k.全局最优：最后都做完插入操作，整个队列满足题目队列属性。

>题十二：用最少数量的箭引爆气球：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/
>>* sl:局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少。有气球最少一箭，无则返回0，每次缩小下一个气球的后区间或前一个气球前区间确保不会重复计算气球重叠（now与before重叠，now与next重叠）

>题十三：无重叠区间：https://leetcode.cn/problems/non-overlapping-intervals/
>>* 局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间(右边界越小，留给下一个区间施展范围越大)，也可以左边界排序，操作与右边界排序相反。后向前遍历
>>* 按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了(逆向操作)
>>* 难点一：一看题就有感觉需要排序，但究竟怎么排序，按左边界排还是右边界排。
>>* 难点二：排完序之后如何遍历，如果没有分析好遍历顺序，那么排序就没有意义了。
>>* 难点三：直接求重复的区间是复杂的，转而求最大非重复区间个数。
>>* 难点四：求最大非重复区间个数时，需要一个分割点来做标记

>题十四：划分字母区间：https://leetcode.cn/problems/partition-labels/
>>* 在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了.
>>* 局部最优：找到之前所有遍历过的字母的最远边界。全局最优：划分出最多的区间。
>>* **很巧妙，得反复咀嚼代码**，另一种思路就是**题十三**思路，给每个字母找到左右区间，然后排序，左到右找最大包容无重叠区间

>题十五：合并区间：https://leetcode.cn/problems/merge-intervals/
>>* 排序，然后遍历，上一个区间的末尾和下一个区间的头比较，若重叠，则合并（改变传入自定义数组的区间范围），最后一个区间可能要额外讨论，因为循环若最后区间不重叠，则要手动在外面添加区间到数组中。

>题十六：单调递增的数字：https://leetcode.cn/problems/monotone-increasing-digits/
>>* 将整型转换为字符串，逐个改变字符.
>>* 局部最优：遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]--，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数。全局最优：得到小于等于N的最大单调递增的整数
从前后向遍历会改变已经遍历过的结果！

>题十七：买卖股票最佳时期含手续费：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-han-sh-rzlz/
>>* 抽象，还是看leetcode官方的贪心解法。

>题十八：监控二叉树：https://leetcode.cn/problems/binary-tree-cameras/
>>* 难，未写。重看
